
<!DOCTYPE html>
<html lang="en"><head>
    <title>Title</title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type"/>
    <meta charset="UTF-8">

</head>
<body>
<canvas id="board-canvas" width="800" height="800"></canvas>
<!-- Note the usage of `type=module` here as this is an ES6 module -->
<script type="module">
    // Use ES module import syntax to import functionality from the module
    // that we have compiled.
    //
    // Note that the `default` import is an initialization function which
    // will "boot" the module and make it ready to use. Currently browsers
    // don't support natively imported WebAssembly as an ES module, but
    // eventually the manual initialization won't be required!
    import init, { greet } from './pkg/wasm_simple.js';

    /** @type {HTMLCanvasElement} */
    const canvas = document.getElementById('board-canvas');
    const ctx = canvas.getContext('2d')

    function drawBoard(board = []) {
        ctx.fillStyle = 'green'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        board.forEach((piece) => {
            switch (piece) {

            }
        })
    }

    async function run() {
        // First up we need to actually load the wasm file, so we use the
        // default export to inform it where the wasm file is located on the
        // server, and then we wait on the returned promise to wait for the
        // wasm to be loaded.
        //
        // It may look like this: `await init('./pkg/without_a_bundler_bg.wasm');`,
        // but there is also a handy default inside `init` function, which uses
        // `import.meta` to locate the wasm file relatively to js file.
        //
        // Note that instead of a string you can also pass in any of the
        // following things:
        //
        // * `WebAssembly.Module`
        //
        // * `ArrayBuffer`
        //
        // * `Response`
        //
        // * `Promise` which returns any of the above, e.g. `fetch("./path/to/wasm")`
        //
        // This gives you complete control over how the module is loaded
        // and compiled.
        //
        // Also note that the promise, when resolved, yields the wasm module's
        // exports which is the same as importing the `*_bg` module in other
        // modes
        window.js_time = function(){
            return Math.round(Date.now() / 1000)
        }
        window.zebra = {
            display_board(arr) {
                console.log(arr)
            }
        }
        await init();
        greet('heyyy')
        // And afterwards we can use all the functionality defined in wasm.
        // const result = add(1, 2);
        // console.log(`1 + 2 = ${result}`);
        // if (result !== 3)
        //     throw new Error("wasm addition doesn't work!");
    }

    run();
</script>
</body>
</html>